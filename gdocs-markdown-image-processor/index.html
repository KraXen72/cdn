<!DOCTYPE html>
<html lang="en" class="theme-preload">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Markdown Image Extractor</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<div class="container">
		<header>
			<h1>Markdown Image Extractor</h1>
			<p class="subtitle">Paste markdown with base64 images to extract and clean</p>
			<div class="header-controls">
				<button id="theme-toggle" class="btn" aria-label="Toggle theme">
					<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"
						viewBox="0 0 24 24"><!-- Icon from Lucide by Lucide Contributors - https://github.com/lucide-icons/lucide/blob/main/LICENSE -->
						<g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
							<circle cx="12" cy="12" r="10" />
							<path d="M12 18a6 6 0 0 0 0-12z" />
						</g>
					</svg>
				</button>
			</div>
		</header>

		<div class="grid">
			<div class="card">
				<div class="card-header">
					<h2>Input Markdown</h2>
					<div class="card-header-buttons">
						<!--             <button id="paste-btn" class="btn btn-primary">Paste</button> -->
						<button id="clear" class="btn">Clear</button>
					</div>
				</div>
				<textarea id="input" placeholder="Paste markdown with images like:
![][image1]

[image1]: <image/png;base64,iVBORw0KG...>"></textarea>
				<div id="error" class="error" style="display:none;"></div>
			</div>

			<div class="card">
				<div class="card-header">
					<h2>Cleaned Markdown</h2>
					<button id="copy-cleaned" class="btn btn-success">ðŸ“‹ Copy</button>
				</div>
				<div id="output" class="card" style="height: 20rem; overflow: auto; background: var(--bg); padding: 0.75rem; font-family: monospace; font-size: 0.875rem;"></div>
			</div>
		</div>

		<div id="images" class="images" style="display:none;">
			<h2 class="card-header">Extracted Images</h2>
			<div id="images-grid" class="images-grid"></div>
		</div>
	</div>

	<script>
		/* Theme initialization: use system by default, persist user's choice in localStorage.
		   Prevent flash by keeping `html.theme-preload` until the theme is applied,
		   then add `theme-ready` to fade in the main content. */
		(function () {
			const THEME_KEY = 'gmdip-theme';
			const doc = document.documentElement;
			const mq = window.matchMedia('(prefers-color-scheme: light)');

			function applyPref(pref) {
				if (pref === 'light') doc.classList.add('skin-theme-clientpref-day');
				else if (pref === 'dark') doc.classList.remove('skin-theme-clientpref-day');
				else {
					if (mq.matches) doc.classList.add('skin-theme-clientpref-day');
					else doc.classList.remove('skin-theme-clientpref-day');
				}
			}

			// React to system changes only when no explicit preference is stored
			if (mq.addEventListener) {
				mq.addEventListener('change', () => {
					if (!localStorage.getItem(THEME_KEY)) applyPref('system');
				});
			} else {
				mq.addListener(() => { if (!localStorage.getItem(THEME_KEY)) applyPref('system'); });
			}

			let stored = localStorage.getItem(THEME_KEY) || 'system';
			applyPref(stored);

			// Reveal and fade-in
			doc.classList.remove('theme-preload');
			void document.body.offsetWidth; // force reflow
			doc.classList.add('theme-ready');

			// Toggle button wiring
			const btn = document.getElementById('theme-toggle');
			if (btn) {
				const updateButton = () => {
					const s = localStorage.getItem(THEME_KEY);
					const effective = s || (mq.matches ? 'light' : 'dark');
					btn.setAttribute('aria-pressed', effective === 'light');
				};

				btn.addEventListener('click', () => {
					const s = localStorage.getItem(THEME_KEY);
					const effective = s || (mq.matches ? 'light' : 'dark');
					const newPref = effective === 'light' ? 'dark' : 'light';
					localStorage.setItem(THEME_KEY, newPref);
					applyPref(newPref);
					updateButton();
				});

				// Right-click resets to system preference (convenience)
				btn.addEventListener('contextmenu', (e) => {
					e.preventDefault();
					localStorage.removeItem(THEME_KEY);
					applyPref('system');
					updateButton();
				});

				updateButton();
			}
		})();

		const input = document.getElementById('input');
		const output = document.getElementById('output');
		const errorEl = document.getElementById('error');
		const imagesSection = document.getElementById('images');
		const imagesGrid = document.getElementById('images-grid');
		const clearBtn = document.getElementById('clear');
		const copyCleanedBtn = document.getElementById('copy-cleaned');

		function showError(msg) {
			errorEl.textContent = msg;
			errorEl.style.display = 'block';
		}

		function hideError() {
			errorEl.style.display = 'none';
		}

		function extractImages(markdown) {
			const images = [];
			let cleaned = markdown;

			// Remove reference definitions: [label]: <...base64...>
			const refDefRegex = /\[([^\]]+)\]:\s*<[^>]*base64,[^>]+>/g;
			let match;
			while ((match = refDefRegex.exec(markdown)) !== null) {
				const [fullMatch, label] = match;
				// Extract base64 data
				const base64Match = fullMatch.match(/base64,([A-Za-z0-9+/=]+)/);
				if (base64Match) {
					images.push({ label, base64Data: base64Match[1] });
				}
				// Replace the whole reference definition with a single newline to preserve paragraph breaks
				cleaned = cleaned.replace(fullMatch, '\n');
			}

			// Remove inline image references: ![][label] and ![alt][label]
			const inlineRefRegex = /!\[[^\]]*\]\[[^\]]*\]/g;
			// Replace inline image refs with a newline so surrounding text doesn't get concatenated
			cleaned = cleaned.replace(inlineRefRegex, '\n');

			// Trim only leading/trailing whitespace but preserve internal blank lines
			return { images, cleaned: cleaned.replace(/\r\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim() };
		}

		function createImageBlob(base64Data) {
			try {
				const cleanBase64 = base64Data.replace(/\s+/g, '');
				const binaryString = atob(cleanBase64);
				const bytes = new Uint8Array(binaryString.length);
				for (let i = 0; i < binaryString.length; i++) {
					bytes[i] = binaryString.charCodeAt(i);
				}
				// Auto-detect image type
				let mimeType = 'image/png';
				if (cleanBase64.startsWith('/9j/')) mimeType = 'image/jpeg';
				else if (cleanBase64.startsWith('R0lGOD')) mimeType = 'image/gif';
				return new Blob([bytes], { type: mimeType });
			} catch (e) {
				return null;
			}
		}

		async function processInput() {
			hideError();
			const text = input.value.trim();
			if (!text) {
				output.innerHTML = '';
				imagesSection.style.display = 'none';
				return;
			}

			const { images, cleaned } = extractImages(text);
			output.innerHTML = cleaned ? `<pre>${cleaned}</pre>` : '<div class="placeholder">No content</div>';

			if (images.length === 0) {
				imagesSection.style.display = 'none';
				return;
			}

			imagesGrid.innerHTML = '';
			imagesSection.style.display = 'block';

			for (const img of images) {
				const blob = createImageBlob(img.base64Data);
				if (!blob) continue;

				const url = URL.createObjectURL(blob);
				const card = document.createElement('div');
				card.className = 'image-card';
				card.innerHTML = `
          <div class="image-label">${img.label}</div>
          <div class="image-preview">
            <img src="${url}" alt="${img.label}">
          </div>
        `;
				// Add error handling for image loading
				card.querySelector('img').onerror = function () {
					this.parentElement.innerHTML = '<div class="placeholder">Invalid image</div>';
				};
				imagesGrid.appendChild(card);
			}
		}

		input.addEventListener('paste', () => {
			setTimeout(processInput, 10);
		});

		input.addEventListener('input', () => {
			if (!input.value.trim()) {
				output.innerHTML = '';
				imagesSection.style.display = 'none';
			}
		});

		clearBtn.addEventListener('click', () => {
			input.value = '';
			output.innerHTML = '';
			imagesSection.style.display = 'none';
			hideError();
		});

		copyCleanedBtn.addEventListener('click', async () => {
			try {
				const text = output.textContent || output.innerText;
				await navigator.clipboard.writeText(text);
				const original = copyCleanedBtn.innerHTML;
				copyCleanedBtn.innerHTML = 'âœ“ Copied!';
				setTimeout(() => copyCleanedBtn.innerHTML = original, 2000);
			} catch (e) {
				showError('Failed to copy');
			}
		});
	</script>
</body>

</html>