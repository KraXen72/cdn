<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NewPipe â†” LibreTube Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-red-400: rgba(255, 84, 89, 1);
            --color-background: var(--color-cream-50);
            --color-surface: var(--color-cream-100);
            --color-text: var(--color-slate-900);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-border: rgba(94, 82, 64, 0.2);
            --color-error: var(--color-red-400);
            --space-4: 4px;
            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --radius-base: 8px;
            --radius-lg: 12px;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --color-slate-900: rgba(245, 245, 245, 1);
                --color-slate-500: rgba(167, 169, 169, 1);
                --color-cream-50: rgba(31, 33, 33, 1);
                --color-cream-100: rgba(38, 40, 40, 1);
                --color-text: var(--color-slate-900);
                --color-text-secondary: rgba(167, 169, 169, 0.7);
                --color-background: var(--color-cream-50);
                --color-surface: var(--color-cream-100);
            }
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
        }

        body {
            padding: var(--space-16);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: var(--space-20);
            flex: 1;
        }

        header {
            text-align: center;
        }

        h1 {
            margin: 0 0 var(--space-8) 0;
            font-size: 28px;
            font-weight: 600;
        }

        .subtitle {
            color: var(--color-text-secondary);
            font-size: 14px;
            margin: 0;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-20);
            flex: 1;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .upload-section {
            display: flex;
            flex-direction: column;
            gap: var(--space-16);
        }

        .upload-section h2 {
            margin: 0 0 var(--space-12) 0;
            font-size: 18px;
            font-weight: 600;
        }

        .file-input-wrapper {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .file-input-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .file-input {
            padding: var(--space-12);
            border: 2px dashed var(--color-border);
            border-radius: var(--radius-base);
            background-color: var(--color-surface);
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-input:hover {
            border-color: var(--color-primary);
            background-color: rgba(33, 128, 141, 0.05);
        }

        .file-input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .file-status {
            font-size: 12px;
            padding: var(--space-8) var(--space-12);
            border-radius: var(--radius-base);
            background-color: rgba(33, 128, 141, 0.1);
            color: var(--color-text);
        }

        .file-status.error {
            background-color: rgba(255, 84, 89, 0.1);
            color: var(--color-error);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: var(--space-12);
            padding: var(--space-16);
            background-color: var(--color-surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-border);
        }

        .mode-selection {
            display: flex;
            flex-direction: column;
            gap: var(--space-12);
        }

        .mode-selection label {
            display: flex;
            align-items: center;
            gap: var(--space-8);
            cursor: pointer;
            font-size: 14px;
        }

        .mode-selection input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .direction-selection {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .direction-selection label {
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: var(--space-8);
        }

        .direction-selection input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-12);
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: 1fr;
            }
        }

        button {
            padding: var(--space-12) var(--space-16);
            border: none;
            border-radius: var(--radius-base);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-hover);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: var(--color-gray-200);
            color: var(--color-text);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-gray-300);
        }

        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .debug-window {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-16);
            max-height: 300px;
            overflow-y: auto;
            font-family: "Courier New", monospace;
            font-size: 12px;
            line-height: 1.5;
        }

        .debug-window h3 {
            margin: 0 0 var(--space-12) 0;
            font-size: 14px;
            font-weight: 600;
        }

        .debug-content {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .debug-line {
            padding: var(--space-4) 0;
            border-bottom: 1px solid var(--color-border);
        }

        .debug-line.info {
            color: var(--color-text);
        }

        .debug-line.success {
            color: var(--color-primary);
        }

        .debug-line.error {
            color: var(--color-error);
        }

        .debug-line.warning {
            color: #ff8c00;
        }

        .schema-display {
            background-color: rgba(33, 128, 141, 0.05);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            padding: var(--space-12);
            margin-top: var(--space-12);
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
            color: var(--color-text-secondary);
        }

        .info-box {
            background-color: rgba(33, 128, 141, 0.1);
            border-left: 3px solid var(--color-primary);
            padding: var(--space-12);
            border-radius: var(--radius-base);
            font-size: 13px;
            line-height: 1.5;
            margin-top: var(--space-12);
        }

        .info-box.warning {
            background-color: rgba(255, 140, 0, 0.1);
            border-left-color: #ff8c00;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 24px;
            }

            .debug-window {
                max-height: 250px;
                font-size: 11px;
            }

            button {
                padding: var(--space-10) var(--space-12);
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ”„ NewPipe â†” LibreTube Converter</h1>
            <p class="subtitle">Convert your YouTube backup between NewPipe and LibreTube formats</p>
        </header>

        <div class="main-content">
            <div class="upload-section">
                <h2>NewPipe Backup</h2>
                <div class="file-input-wrapper">
                    <label class="file-input-label">Upload .zip file</label>
                    <input type="file" id="newpipeFile" class="file-input" accept=".zip" />
                    <div id="newpipeStatus" class="file-status" style="display: none;"></div>
                </div>
                <div class="info-box">
                    <strong>Expected format:</strong> ZIP containing newpipe.db and preferences.json
                </div>
            </div>

            <div class="upload-section">
                <h2>LibreTube Backup</h2>
                <div class="file-input-wrapper">
                    <label class="file-input-label">Upload .json file</label>
                    <input type="file" id="libretubeFile" class="file-input" accept=".json" />
                    <div id="libretubeStatus" class="file-status" style="display: none;"></div>
                </div>
                <div class="info-box">
                    <strong>Expected format:</strong> JSON backup file from LibreTube
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="mode-selection">
                <label>
                    <input type="radio" name="mode" value="merge" checked />
                    <strong>Mode 1: Merge</strong> (Override subscriptions & playlists only)
                </label>
                <label>
                    <input type="radio" name="mode" value="convert" />
                    <strong>Mode 2: Convert</strong> (Generate from single backup)
                </label>
            </div>

            <div class="direction-selection" id="directionSection" style="display: none;">
                <label>Conversion direction:</label>
                <label>
                    <input type="radio" name="direction" value="np2lt" checked />
                    NewPipe â†’ LibreTube
                </label>
                <label>
                    <input type="radio" name="direction" value="lt2np" />
                    LibreTube â†’ NewPipe
                </label>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="convertBtn" disabled>Convert</button>
                <button class="btn-secondary" id="clearBtn">Clear All</button>
            </div>
        </div>

        <div class="debug-window">
            <h3>Debug Output</h3>
            <div id="debugContent" class="debug-content"></div>
        </div>
    </div>

    <script>
        let SQL;
        let newpipeData = null;
        let libretubeData = null;

        // Initialize SQL.js
        async function initSQL() {
            const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.wasm');
            const buffer = await response.arrayBuffer();
            SQL = await initSqlJs({ wasmBinary: buffer });
            debug('SQL.js initialized', 'success');
        }

        // Logging function
        function debug(message, type = 'info') {
            const debugContent = document.getElementById('debugContent');
            const line = document.createElement('div');
            line.className = `debug-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugContent.appendChild(line);
            debugContent.scrollTop = debugContent.scrollHeight;
        }

        // File upload handlers
        document.getElementById('newpipeFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
                debug(`Loading NewPipe backup: ${file.name}`, 'info');
                const arrayBuffer = await file.arrayBuffer();
                const zip = new JSZip();
                await zip.loadAsync(arrayBuffer);

                // Check for required files
                if (!zip.file('newpipe.db')) {
                    throw new Error('newpipe.db not found in ZIP');
                }

                const dbData = await zip.file('newpipe.db').async('arraybuffer');
                const db = new SQL.Database(new Uint8Array(dbData));

                // Load preferences
                let preferences = null;
                if (zip.file('preferences.json')) {
                    const prefsData = await zip.file('preferences.json').async('text');
                    preferences = JSON.parse(prefsData);
                }

                newpipeData = { db, preferences, file };
                updateFileStatus('newpipeStatus', `âœ“ Loaded: ${file.name}`, false);
                debug('âœ“ NewPipe backup loaded successfully', 'success');
                updateConvertButton();
            } catch (error) {
                debug(`âœ— Error loading NewPipe: ${error.message}`, 'error');
                updateFileStatus('newpipeStatus', `âœ— ${error.message}`, true);
                newpipeData = null;
                updateConvertButton();
            }
        });

        document.getElementById('libretubeFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
                debug(`Loading LibreTube backup: ${file.name}`, 'info');
                const text = await file.text();
                const json = JSON.parse(text);

                // Validate structure
                if (!json.subscriptions || !Array.isArray(json.subscriptions)) {
                    throw new Error('Invalid LibreTube format: missing subscriptions array');
                }

                libretubeData = { json, file };
                updateFileStatus('libretubeStatus', `âœ“ Loaded: ${file.name}`, false);
                debug('âœ“ LibreTube backup loaded successfully', 'success');
                updateConvertButton();
            } catch (error) {
                debug(`âœ— Error loading LibreTube: ${error.message}`, 'error');
                updateFileStatus('libretubeStatus', `âœ— ${error.message}`, true);
                libretubeData = null;
                updateConvertButton();
            }
        });

        function updateFileStatus(elementId, message, isError) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.style.display = 'block';
            element.classList.toggle('error', isError);
        }

        function updateConvertButton() {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const btn = document.getElementById('convertBtn');
            
            if (mode === 'merge') {
                btn.disabled = !(newpipeData && libretubeData);
            } else {
                btn.disabled = !(newpipeData || libretubeData);
            }
        }

        document.querySelectorAll('input[name="mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const directionSection = document.getElementById('directionSection');
                if (e.target.value === 'convert') {
                    directionSection.style.display = 'block';
                } else {
                    directionSection.style.display = 'none';
                }
                updateConvertButton();
            });
        });

        // Conversion logic
        async function performConversion() {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            
            try {
                debug('Starting conversion...', 'info');
                
                if (mode === 'merge') {
                    await handleMerge();
                } else {
                    await handleConvert();
                }
            } catch (error) {
                debug(`âœ— Conversion failed: ${error.message}`, 'error');
                console.error(error);
            }
        }

        async function handleMerge() {
            debug('Mode: Merge', 'info');
            // Determine direction
            const direction = document.querySelector('input[name="direction"]:checked').value;
            
            if (direction === 'np2lt') {
                debug('Direction: NewPipe â†’ LibreTube (override subscriptions & playlists)', 'info');
                const merged = await mergeNewPipeToLibreTube();
                downloadJSON(merged, 'libretube-merged.json');
            } else {
                debug('Direction: LibreTube â†’ NewPipe (override subscriptions & playlists)', 'info');
                const { db, zip } = await mergeLibreTubeToNewPipe();
                await downloadNewPipeZip(db, zip);
            }
        }

        async function handleConvert() {
            debug('Mode: Convert', 'info');
            const direction = document.querySelector('input[name="direction"]:checked').value;
            
            if (direction === 'np2lt') {
                debug('Direction: NewPipe â†’ LibreTube', 'info');
                const libretube = await convertNewPipeToLibreTube();
                downloadJSON(libretube, 'newpipe-converted.json');
            } else {
                debug('Direction: LibreTube â†’ NewPipe', 'info');
                const { db, zip } = await convertLibreTubeToNewPipe();
                await downloadNewPipeZip(db, zip);
            }
        }

        // NewPipe â†’ LibreTube conversion
        async function convertNewPipeToLibreTube() {
            debug('Extracting subscriptions from NewPipe...', 'info');
            const subscriptions = extractNewPipeSubscriptions();
            debug(`Found ${subscriptions.length} subscriptions`, 'success');

            debug('Extracting playlists from NewPipe...', 'info');
            const playlists = extractNewPipePlaylists();
            debug(`Found ${playlists.length} playlists`, 'success');

            const result = {
                playlists,
                subscriptions,
                preferences: []
            };

            debug('âœ“ Conversion complete', 'success');
            return result;
        }

        // NewPipe subscription extraction
        function extractNewPipeSubscriptions() {
            const db = newpipeData.db;
            const subs = [];

            try {
                const result = db.exec(`
                    SELECT uid, name, avatar_url, url, subscriber_count
                    FROM subscriptions
                    WHERE service_id = 0
                    ORDER BY name
                `);

                if (result.length > 0) {
                    const columns = result[0].columns;
                    const rows = result[0].values;

                    rows.forEach(row => {
                        const url = row[3];
                        const channelId = extractChannelId(url);
                        
                        if (channelId) {
                            subs.push({
                                channelId,
                                url,
                                name: row[1],
                                avatar: row[2] || '',
                                verified: false
                            });
                        } else {
                            debug(`âš  Skipping subscription with non-YouTube URL: ${url}`, 'warning');
                        }
                    });
                }
            } catch (error) {
                debug(`âœ— Error extracting subscriptions: ${error.message}`, 'error');
            }

            return subs;
        }

        // Channel ID extraction from YouTube URL
        function extractChannelId(url) {
            if (!url) return null;
            
            // Handle youtube.com URLs
            const channelMatch = url.match(/youtube\.com\/channel\/([^/?]+)/);
            if (channelMatch) return channelMatch[1];
            
            // Handle youtube.com/@username URLs
            const usernameMatch = url.match(/youtube\.com\/@([^/?]+)/);
            if (usernameMatch) {
                debug(`âš  YouTube @username found, may not convert correctly: ${url}`, 'warning');
                return null;
            }

            return null;
        }

        // NewPipe playlist extraction
        function extractNewPipePlaylists() {
            const db = newpipeData.db;
            const playlists = [];

            try {
                const result = db.exec(`
                    SELECT uid, name, thumbnail_stream_id
                    FROM playlists
                    ORDER BY name
                `);

                if (result.length > 0) {
                    const rows = result[0].values;

                    rows.forEach(row => {
                        const playlistId = row[0];
                        const playlistName = row[1];

                        // Get videos in playlist
                        const videosResult = db.exec(`
                            SELECT s.url, s.title, s.uploader, s.thumbnail_url, s.duration
                            FROM playlist_stream_join psj
                            JOIN streams s ON psj.stream_id = s.uid
                            WHERE psj.playlist_id = ${playlistId}
                            ORDER BY psj.join_index
                        `);

                        const videos = [];
                        if (videosResult.length > 0) {
                            const videoCols = videosResult[0].columns;
                            const videoRows = videosResult[0].values;

                            videoRows.forEach(videoRow => {
                                const videoUrl = videoRow[0];
                                const videoId = extractVideoId(videoUrl);

                                if (videoId) {
                                    videos.push({
                                        videoId,
                                        url: videoUrl,
                                        title: videoRow[1],
                                        uploader: videoRow[2],
                                        thumbnail: videoRow[3] || '',
                                        duration: videoRow[4] || 0
                                    });
                                }
                            });
                        }

                        playlists.push({
                            name: playlistName,
                            description: '',
                            videos
                        });
                    });
                }
            } catch (error) {
                debug(`âœ— Error extracting playlists: ${error.message}`, 'error');
            }

            return playlists;
        }

        // Video ID extraction
        function extractVideoId(url) {
            if (!url) return null;
            
            // Handle youtube.com/watch?v=ID
            const watchMatch = url.match(/youtube\.com\/watch\?v=([^&]+)/);
            if (watchMatch) return watchMatch[1];
            
            // Handle youtu.be/ID
            const shortMatch = url.match(/youtu\.be\/([^?]+)/);
            if (shortMatch) return shortMatch[1];

            return null;
        }

        // LibreTube â†’ NewPipe conversion
        async function convertLibreTubeToNewPipe() {
            debug('Creating NewPipe SQLite database...', 'info');
            const db = new SQL.Database();

            // Create schema
            debug('Creating database schema...', 'info');
            createNewPipeSchema(db);

            // Insert subscriptions
            debug('Converting subscriptions...', 'info');
            const subscriptions = libretubeData.json.subscriptions || [];
            subscriptions.forEach((sub, index) => {
                try {
                    insertNewPipeSubscription(db, sub);
                } catch (error) {
                    debug(`âš  Error converting subscription "${sub.name}": ${error.message}`, 'warning');
                }
            });
            debug(`âœ“ Converted ${subscriptions.length} subscriptions`, 'success');

            // Insert playlists
            debug('Converting playlists...', 'info');
            const playlists = libretubeData.json.playlists || [];
            playlists.forEach((playlist, index) => {
                try {
                    insertNewPipePlaylist(db, playlist);
                } catch (error) {
                    debug(`âš  Error converting playlist "${playlist.name}": ${error.message}`, 'warning');
                }
            });
            debug(`âœ“ Converted ${playlists.length} playlists`, 'success');

            // Export database
            const data = db.export();
            const dbBuffer = Buffer.from(data);

            // Create ZIP
            debug('Creating ZIP file...', 'info');
            const zip = new JSZip();
            zip.file('newpipe.db', dbBuffer);

            // Add preferences if available
            const preferences = libretubeData.json.preferences || {};
            if (Object.keys(preferences).length > 0) {
                zip.file('preferences.json', JSON.stringify(preferences, null, 2));
                debug('Added preferences.json to ZIP', 'info');
            }

            debug('âœ“ NewPipe ZIP created successfully', 'success');
            return { db, zip };
        }

        // Create NewPipe database schema
        function createNewPipeSchema(db) {
            const schema = `
                CREATE TABLE IF NOT EXISTS android_metadata (locale TEXT);
                CREATE TABLE IF NOT EXISTS subscriptions (
                    uid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                    service_id INTEGER NOT NULL,
                    url TEXT,
                    name TEXT,
                    avatar_url TEXT,
                    subscriber_count INTEGER,
                    description TEXT,
                    notification_mode INTEGER NOT NULL
                );
                CREATE TABLE IF NOT EXISTS streams (
                    uid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                    service_id INTEGER NOT NULL,
                    url TEXT NOT NULL,
                    title TEXT NOT NULL,
                    stream_type TEXT NOT NULL,
                    duration INTEGER NOT NULL,
                    uploader TEXT NOT NULL,
                    uploader_url TEXT,
                    thumbnail_url TEXT,
                    view_count INTEGER,
                    textual_upload_date TEXT,
                    upload_date INTEGER,
                    is_upload_date_approximation INTEGER
                );
                CREATE TABLE IF NOT EXISTS playlists (
                    uid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                    name TEXT,
                    is_thumbnail_permanent INTEGER NOT NULL,
                    thumbnail_stream_id INTEGER NOT NULL,
                    display_index INTEGER NOT NULL
                );
                CREATE TABLE IF NOT EXISTS playlist_stream_join (
                    playlist_id INTEGER NOT NULL,
                    stream_id INTEGER NOT NULL,
                    join_index INTEGER NOT NULL,
                    PRIMARY KEY(playlist_id, join_index),
                    FOREIGN KEY(playlist_id) REFERENCES playlists(uid) ON UPDATE CASCADE ON DELETE CASCADE,
                    FOREIGN KEY(stream_id) REFERENCES streams(uid) ON UPDATE CASCADE ON DELETE CASCADE
                );
                CREATE TABLE IF NOT EXISTS search_history (
                    creation_date INTEGER,
                    service_id INTEGER NOT NULL,
                    search TEXT,
                    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL
                );
                CREATE TABLE IF NOT EXISTS stream_history (
                    stream_id INTEGER NOT NULL,
                    access_date INTEGER NOT NULL,
                    repeat_count INTEGER NOT NULL,
                    PRIMARY KEY(stream_id, access_date),
                    FOREIGN KEY(stream_id) REFERENCES streams(uid) ON UPDATE CASCADE ON DELETE CASCADE
                );
                CREATE TABLE IF NOT EXISTS stream_state (
                    stream_id INTEGER NOT NULL,
                    progress_time INTEGER NOT NULL,
                    PRIMARY KEY(stream_id),
                    FOREIGN KEY(stream_id) REFERENCES streams(uid) ON UPDATE CASCADE ON DELETE CASCADE
                );
                CREATE TABLE IF NOT EXISTS feed (
                    stream_id INTEGER NOT NULL,
                    subscription_id INTEGER NOT NULL,
                    PRIMARY KEY(stream_id, subscription_id),
                    FOREIGN KEY(stream_id) REFERENCES streams(uid) ON UPDATE CASCADE ON DELETE CASCADE,
                    FOREIGN KEY(subscription_id) REFERENCES subscriptions(uid) ON UPDATE CASCADE ON DELETE CASCADE
                );
                CREATE TABLE IF NOT EXISTS feed_group (
                    uid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                    name TEXT NOT NULL,
                    icon_id INTEGER NOT NULL,
                    sort_order INTEGER NOT NULL
                );
                CREATE TABLE IF NOT EXISTS feed_group_subscription_join (
                    group_id INTEGER NOT NULL,
                    subscription_id INTEGER NOT NULL,
                    PRIMARY KEY(group_id, subscription_id),
                    FOREIGN KEY(group_id) REFERENCES feed_group(uid) ON UPDATE CASCADE ON DELETE CASCADE,
                    FOREIGN KEY(subscription_id) REFERENCES subscriptions(uid) ON UPDATE CASCADE ON DELETE CASCADE
                );
                CREATE TABLE IF NOT EXISTS feed_last_updated (
                    subscription_id INTEGER NOT NULL,
                    last_updated INTEGER,
                    PRIMARY KEY(subscription_id),
                    FOREIGN KEY(subscription_id) REFERENCES subscriptions(uid) ON UPDATE CASCADE ON DELETE CASCADE
                );
                CREATE TABLE IF NOT EXISTS remote_playlists (
                    uid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                    service_id INTEGER NOT NULL,
                    name TEXT,
                    url TEXT,
                    thumbnail_url TEXT,
                    uploader TEXT,
                    display_index INTEGER NOT NULL,
                    stream_count INTEGER
                );
                CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY, identity_hash TEXT);
            `;

            schema.split(';').forEach(statement => {
                if (statement.trim()) {
                    try {
                        db.run(statement);
                    } catch (error) {
                        debug(`Schema creation statement error: ${error.message}`, 'warning');
                    }
                }
            });
        }

        // Insert subscription into NewPipe
        function insertNewPipeSubscription(db, subscription) {
            const channelId = subscription.channelId;
            const url = subscription.url || `https://www.youtube.com/channel/${channelId}`;
            const name = subscription.name || 'Unknown';

            db.run(`
                INSERT OR REPLACE INTO subscriptions
                (service_id, url, name, avatar_url, subscriber_count, description, notification_mode)
                VALUES (0, ?, ?, ?, 0, '', 0)
            `, [url, name, subscription.avatar || null]);
        }

        // Insert playlist into NewPipe
        function insertNewPipePlaylist(db, playlist) {
            // Insert playlist
            db.run(`
                INSERT INTO playlists
                (name, is_thumbnail_permanent, thumbnail_stream_id, display_index)
                VALUES (?, 0, 0, 0)
            `, [playlist.name]);

            // Get playlist ID
            const idResult = db.exec('SELECT last_insert_rowid() as id');
            const playlistId = idResult.length > 0 ? idResult[0].values[0][0] : null;

            if (!playlistId) {
                throw new Error('Failed to get playlist ID');
            }

            // Insert videos
            const videos = playlist.videos || [];
            videos.forEach((video, index) => {
                const videoUrl = video.url || `https://www.youtube.com/watch?v=${video.videoId}`;
                const title = video.title || 'Unknown';

                // Insert stream
                db.run(`
                    INSERT OR IGNORE INTO streams
                    (service_id, url, title, stream_type, duration, uploader, uploader_url, thumbnail_url)
                    VALUES (0, ?, ?, 'video_stream', ?, ?, '', ?)
                `, [videoUrl, title, video.duration || 0, video.uploader || 'Unknown', video.thumbnail || null]);

                // Get stream ID
                const streamResult = db.exec(`SELECT uid FROM streams WHERE url = ?`, [videoUrl]);
                const streamId = streamResult.length > 0 ? streamResult[0].values[0][0] : null;

                if (streamId) {
                    // Insert join
                    db.run(`
                        INSERT INTO playlist_stream_join
                        (playlist_id, stream_id, join_index)
                        VALUES (?, ?, ?)
                    `, [playlistId, streamId, index]);
                }
            });
        }

        // Merge NewPipe â†’ LibreTube (keep LibreTube, override subs & playlists)
        async function mergeNewPipeToLibreTube() {
            debug('Merging: keeping LibreTube structure, overriding subscriptions & playlists', 'info');
            
            const subscriptions = extractNewPipeSubscriptions();
            const playlists = extractNewPipePlaylists();

            const merged = JSON.parse(JSON.stringify(libretubeData.json));
            merged.subscriptions = subscriptions;
            merged.playlists = playlists;

            debug(`âœ“ Merged: ${subscriptions.length} subscriptions, ${playlists.length} playlists`, 'success');
            return merged;
        }

        // Merge LibreTube â†’ NewPipe (keep NewPipe, override subs & playlists)
        async function mergeLibreTubeToNewPipe() {
            debug('Merging: keeping NewPipe structure, overriding subscriptions & playlists', 'info');

            const db = newpipeData.db;
            
            // Remove old subscriptions
            debug('Removing old subscriptions...', 'info');
            db.run('DELETE FROM subscriptions WHERE service_id = 0');

            // Remove old playlists
            debug('Removing old playlists...', 'info');
            db.run('DELETE FROM playlists');

            // Insert LibreTube subscriptions
            const subscriptions = libretubeData.json.subscriptions || [];
            subscriptions.forEach(sub => {
                try {
                    insertNewPipeSubscription(db, sub);
                } catch (error) {
                    debug(`âš  Error inserting subscription: ${error.message}`, 'warning');
                }
            });
            debug(`âœ“ Inserted ${subscriptions.length} subscriptions`, 'success');

            // Insert LibreTube playlists
            const playlists = libretubeData.json.playlists || [];
            playlists.forEach(playlist => {
                try {
                    insertNewPipePlaylist(db, playlist);
                } catch (error) {
                    debug(`âš  Error inserting playlist: ${error.message}`, 'warning');
                }
            });
            debug(`âœ“ Inserted ${playlists.length} playlists`, 'success');

            // Create ZIP
            debug('Creating ZIP with merged data...', 'info');
            const data = db.export();
            const dbBuffer = Buffer.from(data);

            const zip = new JSZip();
            zip.file('newpipe.db', dbBuffer);

            // Add preferences from LibreTube if available
            if (libretubeData.json.preferences) {
                zip.file('preferences.json', JSON.stringify(libretubeData.json.preferences, null, 2));
            }

            debug('âœ“ Merge complete', 'success');
            return { db, zip };
        }

        // Download functions
        function downloadJSON(data, filename) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            debug(`âœ“ Downloaded: ${filename}`, 'success');
        }

        async function downloadNewPipeZip(db, zip) {
            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'newpipe-backup.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            debug('âœ“ Downloaded: newpipe-backup.zip', 'success');
        }

        // Event listeners
        document.getElementById('convertBtn').addEventListener('click', performConversion);
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            newpipeData = null;
            libretubeData = null;
            document.getElementById('newpipeFile').value = '';
            document.getElementById('libretubeFile').value = '';
            document.getElementById('newpipeStatus').style.display = 'none';
            document.getElementById('libretubeStatus').style.display = 'none';
            document.getElementById('debugContent').innerHTML = '';
            updateConvertButton();
            debug('Cleared all data', 'info');
        });

        // Utility: Buffer polyfill for browser
        if (typeof Buffer === 'undefined') {
            window.Buffer = class {
                constructor(data) {
                    return new Uint8Array(data);
                }
                static from(data) {
                    return new Uint8Array(data);
                }
            };
        }

        // Initialize
        window.addEventListener('load', initSQL);
    </script>
</body>
</html>
